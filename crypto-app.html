<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–®–∏—Ñ—Ä–∞—Ç–æ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π</title>
  <!-- Telegram WebApp SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root {
      --bg-color: var(--tg-theme-bg-color, #f0f0f0);
      --text-color: var(--tg-theme-text-color, #000);
      --button-color: var(--tg-theme-button-color, #2AABEE);
      --button-text-color: var(--tg-theme-button-text-color, #fff);
      --bubble-outgoing: #dcf8c6; /* —Å–≤–µ—Ç–ª–æ-–∑–µ–ª—ë–Ω—ã–π (–∫–∞–∫ –∏—Å—Ö–æ–¥—è—â–µ–µ –≤ WhatsApp) */
      --bubble-incoming: #fff;    /* –±–µ–ª—ã–π –¥–ª—è –≤—Ö–æ–¥—è—â–∏—Ö */
      --bubble-text-out: #000;
      --bubble-text-in: #000;
    }
    body {
      margin: 0; padding: 0;
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex; flex-direction: column;
      height: 100vh; /* –ø–æ–ª–Ω—ã–π —ç–∫—Ä–∞–Ω */
    }
    header {
      padding: 10px; text-align: center; font-size: 1.1em;
      font-weight: bold;
      background: var(--tg-theme-secondary-bg-color, #e8e8e8);
    }
    #chat {
      flex: 1; overflow-y: auto;
      padding: 10px;
    }
    .message {
      max-width: 80%; padding: 8px 12px;
      margin: 5px; border-radius: 12px;
      word-wrap: break-word;
      line-height: 1.4;
    }
    .outgoing { /* –∏—Å—Ö–æ–¥—è—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è) */
      background: var(--bubble-outgoing);
      color: var(--bubble-text-out);
      align-self: flex-end;
      border-bottom-right-radius: 0; /* —Ñ–∏–≥—É—Ä–Ω—ã–π —Ö–≤–æ—Å—Ç - —É–±–∏—Ä–∞–µ–º —Å–∫—Ä—É–≥–ª–µ–Ω–∏–µ —Å –æ–¥–Ω–æ–≥–æ –∫—Ä–∞—è */
    }
    .incoming { /* –≤—Ö–æ–¥—è—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (—Ä–µ–∑—É–ª—å—Ç–∞—Ç) */
      background: var(--bubble-incoming);
      color: var(--bubble-text-in);
      align-self: flex-start;
      border-bottom-left-radius: 0;
      border: 1px solid #e0e0e0;
    }
    form {
      display: flex; flex-wrap: wrap;
      padding: 10px;
      background: var(--tg-theme-secondary-bg-color, #e8e8e8);
    }
    select, input[type=text] {
      font: inherit;
      margin: 2px;
    }
    select {
      flex: 1 1 40%; min-width: 120px;
    }
    #keyInput {
      flex: 1 1 30%; min-width: 100px;
    }
    #textInput {
      flex: 1 1 100%; /* textarea occupies full width */
      min-height: 50px;
      margin: 5px 2px;
    }
    button {
      flex: 1 1 45%; min-width: 100px;
      margin: 2px;
      background: var(--button-color);
      color: var(--button-text-color);
      border: none; border-radius: 4px;
      padding: 8px;
      font: inherit; font-weight: bold;
      cursor: pointer;
    }
    button:active { opacity: 0.9; }
    #genKeyBtn {
      flex: 0 0 auto;
      background: #ccc;
      color: #000;
      font-size: 1.2em;
      padding: 0 8px;
    }
  </style>
</head>
<body>
  <header>üîê –®–∏—Ñ—Ä–∞—Ç–æ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π</header>
  <div id="chat"></div>
  <form onsubmit="return false;">
    <textarea id="textInput" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ..."></textarea>
    <select id="methodSelect">
      <option value="caesar">–¶–µ–∑–∞—Ä—å</option>
      <option value="atbash">–ê—Ç–±–∞—à</option>
      <option value="vigenere">–í–∏–∂–µ–Ω–µ—Ä</option>
      <option value="base64">Base64</option>
      <option value="fernet">–ü—Å–µ–≤–¥–æ-Fernet</option>
    </select>
    <input type="text" id="keyInput" placeholder="–ö–ª—é—á" />
    <button type="button" id="genKeyBtn" title="–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–ª—é—á">üé≤</button>
    <button type="button" id="encryptBtn">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
    <button type="button" id="decryptBtn">–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
  </form>

  <script>
    const chat = document.getElementById('chat');
    const textInput = document.getElementById('textInput');
    const methodSelect = document.getElementById('methodSelect');
    const keyInput = document.getElementById('keyInput');
    const encryptBtn = document.getElementById('encryptBtn');
    const decryptBtn = document.getElementById('decryptBtn');
    const genKeyBtn = document.getElementById('genKeyBtn');

    // –î–æ—Å—Ç—É–ø–Ω—ã–µ –∞–ª—Ñ–∞–≤–∏—Ç—ã
    const alphabetEng = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const alphabetRus = "–ê–ë–í–ì–î–ï–Å–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø";
    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è: –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –∞–ª—Ñ–∞–≤–∏—Ç –±—É–∫–≤—ã (–ª–∞—Ç–∏–Ω–∏—Ü–∞/–∫–∏—Ä–∏–ª–ª–∏—Ü–∞) –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –º–∞—Å—Å–∏–≤
    function getAlphabet(char) {
      const upper = char.toUpperCase();
      if (alphabetEng.indexOf(upper) !== -1) return alphabetEng;
      if (alphabetRus.indexOf(upper) !== -1) return alphabetRus;
      return null;
    }

    function encryptCaesar(text, shift) {
      let result = "";
      shift = (shift % 33 + 33) % 33; // –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Å–¥–≤–∏–≥ (–¥–ª—è 33 –±—É–∫–≤ –º–∞–∫—Å–∏–º—É–º, —Ö–≤–∞—Ç–∏—Ç –∏ –¥–ª—è 26)
      for (let ch of text) {
        const alphabet = getAlphabet(ch);
        if (!alphabet) { 
          result += ch; // –Ω–µ –±—É–∫–≤–∞, –Ω–µ –º–µ–Ω—è–µ–º
        } else {
          const isLower = (ch === ch.toLowerCase());
          const baseIndex = alphabet.indexOf(ch.toUpperCase());
          // –î–ª—è –ª–∞—Ç–∏–Ω–∏—Ü—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–æ–¥ 26, –¥–ª—è –∫–∏—Ä–∏–ª–ª–∏—Ü—ã –º–æ–¥ 33:
          const mod = alphabet.length;
          let newIndex = (baseIndex + shift) % mod;
          if (newIndex < 0) newIndex += mod;
          let newChar = alphabet[newIndex];
          if (isLower) newChar = newChar.toLowerCase();
          result += newChar;
        }
      }
      return result;
    }
    function decryptCaesar(text, shift) {
      // —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ –¶–µ–∑–∞—Ä—è ‚Äî —Å–¥–≤–∏–≥ –≤ –æ–±—Ä–∞—Ç–Ω—É—é —Å—Ç–æ—Ä–æ–Ω—É
      return encryptCaesar(text, -shift);
    }

    function encryptAtbash(text) {
      let result = "";
      for (let ch of text) {
        const alphabet = getAlphabet(ch);
        if (!alphabet) {
          result += ch;
        } else {
          const isLower = (ch === ch.toLowerCase());
          const idx = alphabet.indexOf(ch.toUpperCase());
          // n -> m-n-1
          const newIdx = alphabet.length - idx - 1;
          let newChar = alphabet[newIdx];
          if (isLower) newChar = newChar.toLowerCase();
          result += newChar;
        }
      }
      return result;
    }
    const decryptAtbash = encryptAtbash; // –æ–±—Ä–∞—Ç–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –ê—Ç–±–∞—à —Ç–∞–∫–æ–µ –∂–µ

    function encryptVigenere(text, key, decrypt=false) {
      let result = "";
      if (!key) return text;
      let keyIndex = 0;
      for (let ch of text) {
        const alphabet = getAlphabet(ch);
        if (!alphabet) {
          result += ch;
        } else {
          const isLower = (ch === ch.toLowerCase());
          const charIdx = alphabet.indexOf(ch.toUpperCase());
          const keyChar = key[keyIndex % key.length];
          const keyAlphabet = getAlphabet(keyChar) || alphabet; 
          // –ï—Å–ª–∏ —Å–∏–º–≤–æ–ª –∫–ª—é—á–∞ –Ω–µ –±—É–∫–≤–∞ (–º–∞–ª–æ–≤–µ—Ä–æ—è—Ç–Ω–æ, –Ω–æ –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π) –∏–ª–∏ –∫–ª—é—á –Ω–∞ –¥—Ä—É–≥–æ–º —è–∑—ã–∫–µ,
          // —Ç–æ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –±–µ—Ä—ë–º —Ç–æ—Ç –∂–µ –∞–ª—Ñ–∞–≤–∏—Ç —á—Ç–æ –∏ —Ç–µ–∫—Å—Ç.
          const keyIdx = keyAlphabet.indexOf(keyChar.toUpperCase());
          let newIdx;
          if (!decrypt) {
            newIdx = (charIdx + keyIdx) % alphabet.length;
          } else {
            newIdx = (charIdx - keyIdx) % alphabet.length;
            if (newIdx < 0) newIdx += alphabet.length;
          }
          let newChar = alphabet[newIdx];
          if (isLower) newChar = newChar.toLowerCase();
          result += newChar;
          keyIndex++;
        }
      }
      return result;
    }
    function decryptVigenere(text, key) {
      return encryptVigenere(text, key, true);
    }

    function encryptBase64(text) {
      // –ö–æ–¥–∏—Ä—É–µ–º –≤ UTF-8 –∏ –ø–æ—Ç–æ–º –≤ Base64
      const utf8Bytes = new TextEncoder().encode(text);
      let binaryStr = "";
      utf8Bytes.forEach(b => { binaryStr += String.fromCharCode(b); });
      return btoa(binaryStr);
    }
    function decryptBase64(base64) {
      try {
        const binaryStr = atob(base64);
        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ Uint8Array
        const bytes = Uint8Array.from(binaryStr, c => c.charCodeAt(0));
        return new TextDecoder().decode(bytes);
      } catch(e) {
        return "[–û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è Base64]";
      }
    }

    function encryptFernet(text, key) {
      if (!key) return text;
      // XOR encryption + Base64
      const textBytes = new TextEncoder().encode(text);
      const keyBytes = new TextEncoder().encode(key);
      const outBytes = textBytes.map((byte, i) => byte ^ keyBytes[i % keyBytes.length]);
      // convert outBytes to binary string for btoa
      let binaryStr = "";
      outBytes.forEach(b => { binaryStr += String.fromCharCode(b); });
      return btoa(binaryStr);
    }
    function decryptFernet(cipherText, key) {
      if (!key) return cipherText;
      try {
        const binaryStr = atob(cipherText);
        const encryptedBytes = Uint8Array.from(binaryStr, c => c.charCodeAt(0));
        const keyBytes = new TextEncoder().encode(key);
        const outBytes = encryptedBytes.map((byte, i) => byte ^ keyBytes[i % keyBytes.length]);
        return new TextDecoder().decode(outBytes);
      } catch(e) {
        return "[–û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏]";
      }
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —á–∞—Ç –∏ localStorage
    function addMessage(text, type) {
      const msgDiv = document.createElement('div');
      msgDiv.className = "message " + (type === 'user' ? 'outgoing' : 'incoming');
      msgDiv.textContent = text;
      // –î–æ–±–∞–≤–ª—è–µ–º –≤ —á–∞—Ç –∏ –ø—Ä–æ–∫—Ä—É—á–∏–≤–∞–µ–º –≤–Ω–∏–∑
      chat.appendChild(msgDiv);
      chat.scrollTop = chat.scrollHeight;
      // –ó–∞–ø–∏—Å—å –≤ –∏—Å—Ç–æ—Ä–∏—é (localStorage)
      saveHistoryItem({ role: type, method: methodSelect.value, text: text });
    }

    // LocalStorage: —Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏
    const HISTORY_KEY = "encryptChatHistory";
    function saveHistoryItem(item) {
      let history = [];
      try {
        history = JSON.parse(localStorage.getItem(HISTORY_KEY)) || [];
      } catch(e) {
        history = [];
      }
      history.push(item);
      localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
    }
    function loadHistory() {
      try {
        const history = JSON.parse(localStorage.getItem(HISTORY_KEY));
        if (history && Array.isArray(history)) {
          for (let item of history) {
            const msgDiv = document.createElement('div');
            msgDiv.className = "message " + (item.role === 'user' ? 'outgoing' : 'incoming');
            msgDiv.textContent = item.text;
            chat.appendChild(msgDiv);
          }
          // –ü—Ä–æ–∫—Ä—É—á–∏–≤–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é –≤–Ω–∏–∑
          chat.scrollTop = chat.scrollHeight;
        }
      } catch(e) { /* –Ω–µ—Ç –≤–∞–ª–∏–¥–Ω–æ–π –∏—Å—Ç–æ—Ä–∏–∏ */}
    }
    loadHistory();

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ –º–µ—Ç–æ–¥–∞: –≤–∫–ª—é—á–µ–Ω–∏–µ/–≤—ã–∫–ª—é—á–µ–Ω–∏–µ –ø–æ–ª—è –∫–ª—é—á–∞
    methodSelect.addEventListener('change', () => {
      const method = methodSelect.value;
      if (method === 'atbash' || method === 'base64') {
        keyInput.disabled = true;
        keyInput.placeholder = "–∫–ª—é—á –Ω–µ –Ω—É–∂–µ–Ω";
      } else {
        keyInput.disabled = false;
        keyInput.placeholder = "–ö–ª—é—á";
      }
    });

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–ª—é—á–∞ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ üé≤
    genKeyBtn.addEventListener('click', () => {
      const method = methodSelect.value;
      let newKey = "";
      if (method === 'caesar') {
        // —Å–ª—É—á–∞–π–Ω–æ–µ —á–∏—Å–ª–æ 1- (–∞–ª—Ñ–∞–≤–∏—Ç-1)
        newKey = Math.ceil(Math.random() * 25).toString(); // –¥–ª—è –∞–Ω–≥–ª. 25; –µ—Å–ª–∏ —Ä—É—Å, –º–æ–∂–Ω–æ –¥–æ 32
      } else if (method === 'vigenere') {
        const alphabet = alphabetEng; // –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∞–Ω–≥–ª, –º–æ–∂–Ω–æ —É–ª—É—á—à–∏—Ç—å: –µ—Å–ª–∏ —Ç–µ–∫—Å—Ç —Ä—É—Å, –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ä—É—Å—Å–∫–∏–µ
        const length = 5 + Math.floor(Math.random()*5); // –¥–ª–∏–Ω–∞ 5-9
        for (let i=0; i<length; i++) {
          newKey += alphabet.charAt(Math.floor(Math.random()*alphabet.length));
        }
      } else if (method === 'fernet') {
        // –ø—Å–µ–≤–¥–æ-Fernet: –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º 16-—Å–∏–º–≤–æ–ª—å–Ω—ã–π –±—É–∫–≤–µ–Ω–Ω–æ-—Ü–∏—Ñ—Ä–æ–≤–æ–π –∫–ª—é—á
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        for (let i=0; i<16; i++) {
          newKey += chars.charAt(Math.floor(Math.random()*chars.length));
        }
      }
      if (newKey) {
        keyInput.value = newKey;
      }
    });

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–Ω–æ–ø–æ–∫ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è/–¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
    encryptBtn.addEventListener('click', () => {
      const method = methodSelect.value;
      const text = textInput.value;
      if (!text) return;
      const key = keyInput.value;
      // –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –∏—Å—Ç–æ—Ä–∏—é (–∏—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç)
      addMessage(text, 'user');
      // –í—ã–±–∏—Ä–∞–µ–º –∞–ª–≥–æ—Ä–∏—Ç–º
      let result;
      switch(method) {
        case 'caesar':
          const shift = parseInt(key) || 0;
          result = encryptCaesar(text, shift);
          break;
        case 'atbash':
          result = encryptAtbash(text);
          break;
        case 'vigenere':
          result = encryptVigenere(text, key || "A"); // –µ—Å–ª–∏ –∫–ª—é—á –Ω–µ —É–∫–∞–∑–∞–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º "A" (—ç—Ñ—Ñ–µ–∫—Ç –Ω—É–ª–µ–≤–æ–π)
          break;
        case 'base64':
          result = encryptBase64(text);
          break;
        case 'fernet':
          result = encryptFernet(text, key || "");
          break;
      }
      addMessage(result, 'app');
      textInput.value = ""; // –æ—á–∏—Å—Ç–∏—Ç—å –ø–æ–ª–µ –≤–≤–æ–¥–∞
    });
    decryptBtn.addEventListener('click', () => {
      const method = methodSelect.value;
      const cipherText = textInput.value;
      if (!cipherText) return;
      const key = keyInput.value;
      // –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (—à–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç) –≤ –∏—Å—Ç–æ—Ä–∏—é
      addMessage(cipherText, 'user');
      let result;
      switch(method) {
        case 'caesar':
          const shift = parseInt(key) || 0;
          result = decryptCaesar(cipherText, shift);
          break;
        case 'atbash':
          result = decryptAtbash(cipherText);
          break;
        case 'vigenere':
          result = decryptVigenere(cipherText, key || "A");
          break;
        case 'base64':
          result = decryptBase64(cipherText);
          break;
        case 'fernet':
          result = decryptFernet(cipherText, key || "");
          break;
      }
      addMessage(result, 'app');
      textInput.value = "";
    });

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑—É–µ–º —Ç–µ–º—É Telegram (–ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –∏ –ø—Ä–∏ —Å–º–µ–Ω–µ)
    Telegram.WebApp.onEvent('themeChanged', () => {
      document.body.style.backgroundColor = Telegram.WebApp.themeParams.bg_color || "#ffffff";
      document.body.style.color = Telegram.WebApp.themeParams.text_color || "#000000";
    });
    Telegram.WebApp.ready(); // –°–æ–æ–±—â–∞–µ–º, —á—Ç–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –æ—Ç—Ä–∏—Å–æ–≤–∞–Ω
  </script>
</body>
</html>
